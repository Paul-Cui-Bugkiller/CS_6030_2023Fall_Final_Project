# CS_6030_2023Fall_Final_Project

Background:
While I was initially tasked with creating a tool to assess code coverage, I encountered a roadblock. 
The current tools in the market seemed quite effective, leaving little room for improvement. 
Amidst my confusion over this dilemma, a friend sought my assistance in debugging his code. 
Aware of ChatGPT's impressive capabilities, I suggested he consult ChatGPT for solutions.
 However, he expressed his frustration, having already exhausted his efforts in that direction. 
Although slightly impatient, I set aside my code coverage project to aid him. 
This decision ultimately led to a pivotal shift in my perspective on choosing my project topic. 
As I observed my friend's interaction with GPT, I noticed that he was relying on it to identify potential bugs. 
This observation sparked a novel idea in my mind – why not explore ways to enhance the efficiency of utilizing ChatGPT in programming environments?

Motivation
The project's motivation stems from recognizing the limitations of conventional code analysis methods, like Randoop and fuzz testing. 
These traditional approaches often fall short in efficiency due to three key drawbacks: their inherent randomness, the absence of logical 
explanations for their findings, and constraints imposed by specific programming languages. This project proposes a novel approach: l
everaging ChatGPT as an alternative tool for code analysis. The central question driving this project is not just about integrating ChatGPT 
into the analysis process, but rather, how to optimize its use to ensure it outperforms traditional methods. We aim to explore strategies 
and frameworks that can effectively utilize ChatGPT's capabilities, ensuring that it provides a more efficient, logical, and versatile solution
for code analysis than its predecessors.

Analysis Steps:
1. File Analysis
2. Prompt Generation
3. Generating output by Large Language Model

Instrructions on reading my codes:
1. real.c
- A video decoding module for Real.
-This is the row code without file analysis.
3. real-fix.c
-This is the fixed version of original real.c after implementing the 3 steps of prompt engineering and follow the improved output generated by LLM.
4. vlc_common.h
-This code provides the reference so that I can find the related class of the classes which might envolve in the issues in real.c. The example of GetDWBE is found here. 
5. AudioAnalyzer.swift
-VLC player’s Real decoding module.
-This code is the original version of the example of swift code mentioned in the "Futural Enhancement" part.
6. AudioAnalyzer-with-deprecation-warning.swift
-This code is with the deprecation issue. Also, this code is an edited version of AudioAnalyzer.swift. I followed the output generted by LLM with constarins and offered context so that there is no obvious bugs but a potential risk warning.
7. AudioEngine-generated.swift
-This code is edited by following the guide from Apple.
The following is the introduction of the method: Apple's shift towards Swift 6, with its emphasis on strict concurrency-safe coding, comes alongside major updates to iOS that introduce new SDKs. This transition has led Apple to phase out older methodologies in favor of more contemporary approaches. A key feature in Xcode, Apple's Integrated Development Environment (IDE), is the ability to easily identify concurrency and thread-safety issues. This is achieved by enabling strict concurrency checking within the project settings.
A straightforward method to ensure data processing occurs on the main thread involves the use of the @MainActor flag. This flag can be applied either to specific methods or to an entire class. Its role is pivotal in leveraging the compiler's understanding of the code, aiming to operate within defined actor boundaries. However, it's important to note that simply using the @MainActor flag does not automatically make existing code compliant with Swift 6, especially when data within an execution block crosses these actor boundaries.
The concept of a Swift actor, introduced in Swift 5.5, is central to these updates. Swift actors are a concurrency feature designed to manage shared mutable state safely and efficiently. Functioning as a type of object, they can be accessed concurrently across multiple threads. What sets them apart is their ability to ensure that access to their mutable state is serialized and thread-safe, marking a significant advancement in Swift's approach to modern, safe coding practices.

Conclusion:
Our exploration into Prompt Engineering reveals that while it may appear straightforward, 
as evidenced by our example, it is in fact a multifaceted and intricate process. 
The effectiveness of Prompt Engineering hinges on the precision and adequacy of the information (or hints) provided to the model. 
This is crucial for producing outputs that are not just relevant, but also of practical utility. 
A prime illustration of this is found in the realm of AI-generated imagery. 
It is evident that the quality of prompts directly influences the resultant image quality. 
Professional artists, with their detailed and accurate descriptions, 
can elicit far superior images from AI models compared to novices who might input vague or simplistic sentences and expect detailed outcomes. 
This disparity underscores the significance of skillful Prompt Engineering in optimizing the capabilities of AI models, a key takeaway from our project findings.
    
